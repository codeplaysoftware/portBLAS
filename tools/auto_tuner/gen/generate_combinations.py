#!/usr/bin/env python

import sys
import json

from itertools import product

ofile = None

LOCAL = "Local"
NON_LOCAL = "NonLocal"
NAIVE = "Naive"


def cbool(bool):
    """ Convert Python bool to string "true" or "false" """
    return "true" if bool else "false"


def writeln(str):
    """ Print given line to output, then flushes """
    ofile.write(str)
    ofile.write("\n")
    ofile.flush()


def write(str):
    """ Print given line to output, with no flush """
    ofile.write(str)


def print_entry_local(cache_line_size, tile, double_buffer, nbca, nbcb):
    """ Print a call to the "local" Gemm tuning """
    writeln("tune<{}, Tile<{}>, {}, {}, {}, {}>(rep, args);".format(
        cache_line_size, ", ".join(map(str, tile)), cbool(double_buffer),
        cbool(nbca), cbool(nbcb), LOCAL))


def print_entry_nonlocal(cache_line_size, tile):
    """ Print a call to the "non-local" Gemm tuning """
    writeln("tune<{}, Tile<{}>, false, false, false, {}>(rep, args);".format(
        cache_line_size, ", ".join(map(str, tile)), NON_LOCAL))


def print_entry_naive(cache_line_size, tile):
    """ Print a call to the "naive" Gemm tuning """
    writeln("tune<{}, Tile<>, false, false, false, {}>(rep, args);".format(
        cache_line_size, NAIVE))


def main():
    global ofile
    if len(sys.argv) < 2:
        sys.stderr.write("{} config [output]\n".format(sys.argv[0]))
        sys.exit(1)

    ofile = sys.stdout
    if len(sys.argv) > 2:
        ofile = open(sys.argv[2], "wt")

    config = json.load(open(sys.argv[1]))

    writeln("// **** FILE AUTOGENERATED BY gen/generate_combinations.py ****")
    writeln("// Config from: {}".format(sys.argv[1]))
    writeln("")

    for r in config.get("local", []):
        for (cls, item, wg) in product(r["cache_line_size"], r["item"],
                                       r["item_level_tiles"]):
            for (tl, db, ncba, ncbb) in product(r["block_level_tiles"],
                                                r["double_buffer"],
                                                r["no_bank_conflict_a"],
                                                r["no_bank_conflict_b"]):
                print_entry_local(cls, item + wg + tl, db, ncba, ncbb)
            writeln("")

    for r in config.get("non_local", []):
        for cls in r["cache_line_size"]:
            for item in r["item"]:
                for wg in r["item_level_tiles"]:
                    print_entry_nonlocal(cls, item + wg)
            writeln("")

    for r in config.get("naive", []):
        for cls in r["cache_line_size"]:
            print_entry_naive(cls, item + wg)


if __name__ == "__main__":
    main()
