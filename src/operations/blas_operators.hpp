/***************************************************************************
 *
 *  @license
 *  Copyright (C) Codeplay Software Limited
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  For your convenience, a copy of the License has been included in this
 *  repository.
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  SYCL-BLAS: BLAS implementation using SYCL
 *
 *  @filename blas_operators.hpp
 *
 **************************************************************************/
// NO H for this one as this one is internal. but all the macro will be
// generated by cmake in cpp file
#ifndef SYCL_BLAS_OPERATORS_HPP
#define SYCL_BLAS_OPERATORS_HPP

#include "blas_constants.hpp"
#include "operations/blas_operators.h"
#include <CL/sycl.hpp>
#include <iostream>
#include <stdexcept>
#include <vector>

namespace blas {
struct Operators {};

/*!
@def Macro for defining a unary operator.
@param name Name of the operator.
@param expr Return expression of the eval function of the oeprator.
*/
#define SYCLBLAS_DEFINE_UNARY_OPERATOR(name, expr)      \
  struct name : public Operators {                      \
    template <typename rhs_t>                           \
    static SYCL_BLAS_INLINE rhs_t eval(const rhs_t r) { \
      return expr;                                      \
    }                                                   \
  };

/*!
@brief Macro for defining a binary operator.
@param name Name of the operator.
@param inital Initial value used in the init function of the operator.
@param expr Return expression of the eval function of the operator.
*/
#define SYCLBLAS_DEFINE_BINARY_OPERATOR(Name, initial_t, expr)         \
  struct Name : public Operators {                                     \
    template <typename lhs_t, typename rhs_t>                          \
    static SYCL_BLAS_INLINE typename StripASP<rhs_t>::type eval(       \
        const lhs_t &l, const rhs_t &r) {                              \
      return expr;                                                     \
    }                                                                  \
                                                                       \
    template <typename rhs_t>                                          \
    constexpr static SYCL_BLAS_INLINE typename rhs_t::value_t init() { \
      return constant<typename rhs_t::value_t, initial_t>::value();    \
    }                                                                  \
  };

/* StripASP.
 * When using ComputeCpp CE, the Device Compiler uses Address Spaces
 * to deal with the different global memories.
 * However, this causes problem with std type traits, which see the
 * types with address space qualifiers as different from the C++
 * standard types.
 *
 * This is StripASP function servers as a workaround that removes
 * the address space for various types.
 */
template <typename type_with_address_space_t>
struct StripASP {
  typedef type_with_address_space_t type;
};

#if defined(__SYCL_DEVICE_ONLY__) && defined(__COMPUTECPP__)
#define GENERATE_STRIP_ASP(entry_type, pointer_type)                   \
  template <>                                                          \
  struct StripASP<typename std::remove_pointer<                        \
      typename cl::sycl::pointer_type<entry_type>::pointer_t>::type> { \
    typedef entry_type type;                                           \
  };

#define GENERATE_STRIP_ASP_LOCATION(data_t) \
  GENERATE_STRIP_ASP(data_t, constant_ptr)  \
  GENERATE_STRIP_ASP(data_t, private_ptr)   \
  GENERATE_STRIP_ASP(data_t, local_ptr)     \
  GENERATE_STRIP_ASP(data_t, global_ptr)

#define GENERATE_STRIP_ASP_TUPLE(data_t, index_t, pointer_type)     \
  template <>                                                       \
  struct StripASP<                                                  \
      typename std::remove_pointer<typename cl::sycl::pointer_type< \
          IndexValueTuple<data_t, index_t>>::pointer_t>::type> {    \
    typedef IndexValueTuple<data_t, index_t> type;                  \
  };

#define INDEX_VALUE_STRIP_ASP_LOCATION(data_t, index_t)   \
  GENERATE_STRIP_ASP_TUPLE(data_t, index_t, constant_ptr) \
  GENERATE_STRIP_ASP_TUPLE(data_t, index_t, private_ptr)  \
  GENERATE_STRIP_ASP_TUPLE(data_t, index_t, local_ptr)    \
  GENERATE_STRIP_ASP_TUPLE(data_t, index_t, global_ptr)
#endif  // __SYCL_DEVICE_ONLY__  && __COMPUTECPP__

/**
 * AbsoluteValue.
 *
 * SYCL 1.2 defines different functions for abs for floating point
 * and integer numbers, following the OpenCL convention.
 * To choose the appropriate one we use this template specialization
 * that is enabled for floating point to use fabs, and abs for everything
 * else.
 */
struct AbsoluteValue {
  template <typename value_t>
  static SYCL_BLAS_INLINE value_t
  eval(const value_t &val,
       typename std::enable_if<!std::is_floating_point<
           typename StripASP<value_t>::type>::value>::type * = 0) {
    return cl::sycl::abs(val);
  }

  template <typename value_t>
  static SYCL_BLAS_INLINE value_t
  eval(const value_t &val,
       typename std::enable_if<std::is_floating_point<
           typename StripASP<value_t>::type>::value>::type * = 0) {
    return cl::sycl::fabs(val);
  }
};

#if defined(__SYCL_DEVICE_ONLY__) && defined(__COMPUTECPP__)
GENERATE_STRIP_ASP_LOCATION(double)
GENERATE_STRIP_ASP_LOCATION(float)
INDEX_VALUE_STRIP_ASP_LOCATION(float, int)
INDEX_VALUE_STRIP_ASP_LOCATION(float, long)
INDEX_VALUE_STRIP_ASP_LOCATION(float, long long)
INDEX_VALUE_STRIP_ASP_LOCATION(double, int)
INDEX_VALUE_STRIP_ASP_LOCATION(double, long)
INDEX_VALUE_STRIP_ASP_LOCATION(double, long long)
#endif

/*!
Definitions of unary, bianry and ternary operators using the above macros.
*/
SYCLBLAS_DEFINE_UNARY_OPERATOR(AdditionIdentity,
                               (constant<rhs_t, const_val::zero>::value()))
SYCLBLAS_DEFINE_UNARY_OPERATOR(ProductIdentity,
                               (constant<rhs_t, const_val::one>::value()))
SYCLBLAS_DEFINE_UNARY_OPERATOR(IdentityOperator, (r))
SYCLBLAS_DEFINE_UNARY_OPERATOR(NegationOperator, (-r))
SYCLBLAS_DEFINE_UNARY_OPERATOR(SqrtOperator, (cl::sycl::sqrt(r)))
SYCLBLAS_DEFINE_UNARY_OPERATOR(DoubleOperator, (r + r))
SYCLBLAS_DEFINE_UNARY_OPERATOR(SquareOperator, (r * r))
SYCLBLAS_DEFINE_BINARY_OPERATOR(AddOperator, const_val::zero, (l + r))
SYCLBLAS_DEFINE_BINARY_OPERATOR(ProductOperator, const_val::one, (l * r))
SYCLBLAS_DEFINE_BINARY_OPERATOR(DivisionOperator, const_val::one, (l / r))
SYCLBLAS_DEFINE_BINARY_OPERATOR(MaxOperator, const_val::min, ((l > r) ? l : r))
SYCLBLAS_DEFINE_BINARY_OPERATOR(MinOperator, const_val::max, ((l < r) ? l : r))
SYCLBLAS_DEFINE_BINARY_OPERATOR(AbsoluteAddOperator, const_val::zero,
                                (AbsoluteValue::eval(l) +
                                 AbsoluteValue::eval(r)))
SYCLBLAS_DEFINE_BINARY_OPERATOR(
    IMaxOperator, const_val::imax,
    (AbsoluteValue::eval(
         static_cast<typename StripASP<lhs_t>::type>(l).get_value()) <
         AbsoluteValue::eval(
             static_cast<typename StripASP<rhs_t>::type>(r).get_value()) ||
     (AbsoluteValue::eval(
          static_cast<typename StripASP<lhs_t>::type>(l).get_value()) ==
          AbsoluteValue::eval(
              static_cast<typename StripASP<rhs_t>::type>(r).get_value()) &&
      l.get_index() > r.get_index()))
        ? static_cast<typename StripASP<rhs_t>::type>(r)
        : static_cast<typename StripASP<lhs_t>::type>(l))
SYCLBLAS_DEFINE_BINARY_OPERATOR(
    IMinOperator, const_val::imin,
    (AbsoluteValue::eval(
         static_cast<typename StripASP<lhs_t>::type>(l).get_value()) >
         AbsoluteValue::eval(
             static_cast<typename StripASP<rhs_t>::type>(r).get_value()) ||
     (AbsoluteValue::eval(
          static_cast<typename StripASP<lhs_t>::type>(l).get_value()) ==
          AbsoluteValue::eval(
              static_cast<typename StripASP<rhs_t>::type>(r).get_value()) &&
      l.get_index() > r.get_index()))
        ? static_cast<typename StripASP<rhs_t>::type>(r)
        : static_cast<typename StripASP<lhs_t>::type>(l))

}  // namespace blas

#endif  // BLAS_OPERATORS_HPP
